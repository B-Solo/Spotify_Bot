from __future__ import print_function

import spotipy
from spotipy.oauth2 import SpotifyOAuth
import tokens
import json

import pickle
import os.path
import re

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import httplib2


# To activate virtual environment, do .venv\Scripts\activate


# Given a playlist_id, returns a list of names of the tracks in that playlist
def get_track_names_from_playlist(playlist_id):
    scope = "playlist-read-private"
    sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=tokens.CLIENT_ID, client_secret= tokens.CLIENT_SECRET, redirect_uri=tokens.REDIRECT_URL, scope=scope))


    track_names = []

    #Spotipy will only pull 100 items at a time, despite knowing the whole length of the playlist
    #This is due to 'paging' which there was minimal information on when I originally wrote the code
    #https://www.reddit.com/r/learnpython/comments/phuw42/spotify_api_100_track_limit/
    #this thread however seems to explain how to deal with the paging
    #but for the time being, this is the solution: just request the tracks with offsets of 100
    #and
    playlist_length = sp.playlist_items(playlist_id)["total"]

    def get_track_name(x) : return x["track"]["name"] if x["track"] != None else None
    while len(track_names) < playlist_length:
        response = sp.playlist_items(playlist_id, limit=100, offset=len(track_names))
        #unwrap the response items
        #so we end up with the individual song items, rather than a list of 8 blocks of 100
        track_names.extend(map(lambda x : get_track_name(x), response["items"])) 
    
    
    return list(filter(lambda x : x != None, track_names))



def get_values_from_spreadsheet(spreadsheet_id, range_name, concatenate=False):
    scopes = ['https://www.googleapis.com/auth/spreadsheets']
    credentials = get_credentials(scopes)

    try:
        service = build('sheets', 'v4', credentials=credentials)

        # Call the Sheets API
        sheet = service.spreadsheets()
        result = sheet.values().get(spreadsheetId=spreadsheet_id, range=range_name).execute()
        values = result.get('values', [])

        if not values:
            print('No data found.')
            return

        if concatenate:
            result = []
            [result.extend(x) for x in values]
            values = result
        
        return values
    
    except HttpError as err:
        print(err)


def alter_spreadsheet(spreadsheet_id, location_name, new_value):
    scopes = ['https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive']
    credentials = get_credentials(scopes)

    try:
        service = build('sheets', 'v4', credentials=credentials)

        # Call the Sheets API
        sheet = service.spreadsheets()
        result = sheet.values().update(spreadsheetId=spreadsheet_id, range=location_name, valueInputOption='RAW', body = new_value).execute()
        
        return True
    
    except HttpError as err:
        print(err)


    # The file token.json stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first time.

    # On the other hand, credentials.json stores our app's tokens to be allowed to communicate
    # with the google servers - i.e. how google knows to trust this app.
    # Provided you have these, you can request tokens for users.
        
    # This function will get those user's access and refresh tokens.
def get_credentials(scopes):
    creds = None

    if os.path.exists('token.json'):
        creds = Credentials.from_authorized_user_file('token.json', scopes)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
            #was getting error here "Refresh Error, invalid_grant". 
            #this is because google kills the refresh token after 6 months
            #https://developers.google.com/identity/protocols/oauth2#expiration
            except:
                print("Attempting to refresh the credentials did not succeed.\nGenerating new credentials.")
                os.remove('token.json') #TODO: This wasn't successfully deleting the token file, which then
                # needs to be regenerated by the code below in this case
                # print(os.path.exists('token.json'))
                # If this is causing errors, just manually delete token.json and rerun
        else:
            flow = InstalledAppFlow.from_client_secrets_file('credentials.json', scopes)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open('token.json', 'w') as token:
            print("User token was regenerated")
            token.write(creds.to_json())

    return creds


#given the name of a cell as a string, return the string for the letter code for its column,
#and the integer number for its row
def find_row_col(cell):
    i = 0
    while(cell[i].isalpha()):
        i += 1

    return cell[:i], int(cell[i:])


# Given a playlist, and a location of a (vertical) range on a spreadsheet, and possibly a file of rows to ignore,
# compare the track names of the playlist to the rows of the range, adjusting the spreadsheet (or recording
# further rows to ignore) as desired via the command line.
def consolidate_playlist_with_spreadsheet_col(playlist_id, spreadsheet_id, sheet_name, first_cell, approved_rows_file=""):
    
    col, first_row = find_row_col(first_cell)

    spreadsheet_values = get_values_from_spreadsheet(spreadsheet_id, sheet_name + "!" + first_cell + ":" + col + str(first_row + 10000), concatenate=True)
    track_names = get_track_names_from_playlist(playlist_id)

    print(f"Have detected {len(spreadsheet_values)} rows of the spreadsheet, for {len(track_names)} tracks in the playlist")

    # This will ensure we have at least as many spreadsheet spaces as tracks, so that if we add
    # new tracks, the program will let us add them to the spreadsheet
    while(len(spreadsheet_values) < len(track_names)): 
        spreadsheet_values.append("")



    try:
        approved_rows = pickle.load(open(approved_rows_file, 'rb'))
    except:
        approved_rows = set()
    
    for i, (name_in_sheet, track_name) in enumerate(zip(spreadsheet_values, track_names)):
        if re.sub(r'â€™', r'\'', name_in_sheet.lower()) != track_name.lower() and (i not in approved_rows):
            print("Conflict on entry " + str(i+1) + ":\nIn spreadsheet as:     " + name_in_sheet + ".\nSpotify track name is: " + track_name + 
                  ".\nPress r to overwrite sheet, a to accept the difference, t to type a different entry for this row, or b to break")
            response = input()
            if response == 'r':
                alter_spreadsheet(spreadsheet_id, sheet_name + "!" + col + str(i+2), {'values': [[track_name]]})
            elif response == 'a':
                approved_rows.add(i)
            elif response == 't':
                new_row_text = input("Enter the text for this row:")
                alter_spreadsheet(spreadsheet_id, sheet_name + "!" + col + str(i+2), {'values': [[new_row_text]]})
                approved_rows.add(i)
            else:
                break

    print("No further conflicts.")

    with open(approved_rows_file, 'wb') as outfile:
        pickle.dump(approved_rows, outfile)



def main():
    EVERYTHING_ID = 'https://open.spotify.com/playlist/36d5XdCBocMKCXpFS1JoQ8?si=f0a4d20ecb764313'
    SONGS_2023_ID = 'https://open.spotify.com/playlist/37i9dQZF1Fa1IIVtEpGUcU?si=b409fff09912444d'
    SONGS_2022_ID = 'https://open.spotify.com/playlist/37i9dQZF1F0sijgNaJdgit?si=481888f3f4404b6a'
    SONGS_2021_ID = 'https://open.spotify.com/playlist/37i9dQZF1EUMDoJuT8yJsl?si=83094f9117684fbc'
    SONGS_2020_ID = 'https://open.spotify.com/playlist/37i9dQZF1EMg6nWsb4kEDa?si=1602964d65994708'
    SONGS_2019_ID = 'https://open.spotify.com/playlist/37i9dQZF1EthgUig02pBIz?si=943706dee97d4b82'

    YOUR_TOP_SONGS = [SONGS_2019_ID, SONGS_2020_ID, SONGS_2021_ID, SONGS_2022_ID, SONGS_2023_ID]
    MUSIC_SHEET_ID = '1apQT3YSnxTkZEw0N3PaSpFja7uzbvWJyZ6nHj4bzpN4'
    #consolidate_playlist_with_spreadsheet_col(EVERYTHING_ID, MUSIC_SHEET_ID, 'Ben V3', 'A2', "EverythingSheetDiffs.txt")

    dict = {}
    for year in YOUR_TOP_SONGS:
        for track in get_track_names_from_playlist(year):
            dict[track] = dict[track] + 1 if track in dict else 1

    print(sorted( ((v,k) for k,v in dict.items()), reverse=True)[:20])



    




   
    
    


if __name__ == '__main__':
    main()